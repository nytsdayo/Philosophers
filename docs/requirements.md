食事する哲学者の問題 シミュレーションプログラム 要件定義書
## 概要

食事する哲学者の問題 (Dining Philosophers Problem)をベースとした問題を解く。
哲学者を一つの実行単位とみなし、非同期通信や並行処理・並列処理など、非同期通信において大切となる要素の理解へとつながるとされる。

この問題は、複数の並行プロセス（哲学者）が限られた共有リソース（フォーク）を巡って競合する状況をモデル化しており、デッドロックやスタベーションといった並行処理における同期の問題を理解し、その解決策を実装する学習課題として広く用いられています。
## 目的
- 非同期通信の基本の獲得
•POSIXスレッド（またはプロセス）の生成と操作を習得する。
•共有リソースへの排他制御のための同期プリミティブ（ミューテックス、セマフォ）の利用方法を理解する。
•並行処理におけるデッドロックやスタベーションの問題を認識し、回避または解決する手法を実装する。
•適切なログ出力、メモリ管理、データ競合の回避など、実践的なプログラミングスキルを習得する。

## 要件
### 引数
- `哲学者の数`,`最大食事間隔`,`哲学者の食事時間`,`哲学者の睡眠時間` , `最低食事回数(任意)`を受け取る。
- それぞれの引数の範囲について`1`~`INT_MAX`と定義する。（独自定義）
### 停止条件
- いずれかの哲学者が死亡した場合、シミュレーションは即座に停止します。
- オプション引数 number_of_times_each_philosopher_must_eat が指定されており、全ての哲学者がその回数以上の食事を完了した場合、シミュレーションは停止します。

### 哲学者について
#### 行動
- 思考 (thinking)、食事 (eating)、睡眠 (sleeping) のサイクルを繰り返す。
- 食事には両隣のフォークが必要です。
- 食事が終わると、フォークを置いて睡眠し、その後思考に戻ります。
#### 哲学者の情報 
- 各哲学者は1から number_of_philosophers までの番号を持ちます。哲学者1は哲学者 number_of_philosophers の隣に座り、それ以外の哲学者Nは哲学者N-1と哲学者N+1の間に座るという円卓の配置を想定します。
- 各哲学者は、最後に食事を開始した時刻 (last_eat_time) を記録する必要があります。
- オプション引数がある場合、各哲学者は食事を完了した回数 (eat_count) を記録する必要があります。
- 各哲学者は自身の座席番号 (seat_number) を持つ必要があります。
- 哲学者は、食事会の設定情報や同期プリミティブ（ミューテックスやセマフォ）、シミュレーションの状態を管理する共有情報へのアクセス（ポインタなど）を持つ必要があります。
•
### 制約事項
- プログラムにデータ競合があってはなりません。
- 哲学者は互いに話したり、他の哲学者が死にかけていることを知ったりしません。
- 哲学者は死を避けるべきです。
### ログ出力:
- 哲学者の状態変化は、以下の指定されたフォーマットで標準出力にログとして出力する必要があります。
```
▪timestamp_in_ms X has taken a fork
▪timestamp_in_ms X is eating
▪timestamp_in_ms X is sleeping
▪timestamp_in_ms X is thinking
▪timestamp_in_ms X died (timestamp_in_ms はシミュレーション開始からの経過時間、X は哲学者の番号 (1-based) に置き換えます)。
◦ログメッセージは、他のメッセージと混ざって出力されないように保護する必要があります。
◦哲学者が死亡したことを知らせるメッセージ (timestamp_in_ms X died) は、実際の死亡から10ミリ秒以内に表示する必要があります。
```
