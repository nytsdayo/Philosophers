はい、承知いたしました。pthread_mutex関連の関数についてMarkdown形式で説明します。

pthread_mutex関連関数について
pthread_mutex（ミューテックス）は、複数のスレッドが同時に共有リソース（変数やデータ構造など）にアクセスしようとしたときに、問題が発生するのを防ぐための仕組み（排他制御）です。ここでは、pthread_mutexに関連する主要な関数について説明します。

1. ミューテックスの初期化
ミューテックスを使用する前に、初期化する必要があります。初期化には2つの方法があります。

pthread_mutex_init() (動的な初期化)
プログラムの実行中にミューテックスを作成する場合に使います。
ミューテックスの属性（種類など）を細かく設定したい場合にもこちらを使います。
使い方:

C

#include <pthread.h>

pthread_mutex_t mutex;
pthread_mutexattr_t attr; // 必要に応じて属性を設定

// デフォルトの属性で初期化する場合
int result = pthread_mutex_init(&mutex, NULL);
if (result != 0) {
    // エラー処理
}

/*
// 属性を指定して初期化する場合 (例: エラーチェック付きミューテックス)
pthread_mutexattr_init(&attr);
pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK);
result = pthread_mutex_init(&mutex, &attr);
pthread_mutexattr_destroy(&attr); // 属性オブジェクトは不要になったら破棄
if (result != 0) {
    // エラー処理
}
*/
引数:
第1引数: 初期化するミューテックスオブジェクト (pthread_mutex_t型) のアドレス。
第2引数: ミューテックスの属性 (pthread_mutexattr_t型) のアドレス。NULL を指定するとデフォルトの属性になります。
戻り値: 成功すると 0 を返します。失敗するとエラーコードを返します。
PTHREAD_MUTEX_INITIALIZER (静的な初期化)
グローバル変数や静的変数としてミューテックスを宣言するときに、簡単に初期化できるマクロです。
デフォルトの属性で初期化されます。
使い方:

C

#include <pthread.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
注意点: この方法で初期化されたミューテックスは、pthread_mutex_destroy() で破棄する必要はありません（できません）。
2. ミューテックスの破棄
pthread_mutex_init() で動的に初期化したミューテックスは、不要になったら破棄する必要があります。

pthread_mutex_destroy()
ミューテックスが使用していたリソースを解放します。
使い方:

C

int result = pthread_mutex_destroy(&mutex);
if (result != 0) {
    // エラー処理
}
引数: 破棄するミューテックスオブジェクトのアドレス。
戻り値: 成功すると 0 を返します。失敗するとエラーコード（例えば、ミューテックスがロックされている場合など）を返します。
注意点: ロックされている状態のミューテックスを破棄しようとすると、未定義の動作を引き起こす可能性があります。必ずアンロックしてから破棄してください。
3. ミューテックスのロック
共有リソースにアクセスする前に、ミューテックスをロックして他のスレッドがアクセスできないようにします。

pthread_mutex_lock()
ミューテックスをロックしようとします。
もし他のスレッドがすでにミューテックスをロックしている場合は、そのスレッドがアンロックするまで待ち続けます（ブロックします）。
使い方:

C

int result = pthread_mutex_lock(&mutex);
if (result != 0) {
    // エラー処理 (デッドロック検出など、ミューテックスの種類による)
}
// --- クリティカルセクション（共有リソースへのアクセス） ---
// ...
// --- クリティカルセクション終了 ---
pthread_mutex_unlock(&mutex); // 必ずアンロックする
引数: ロックするミューテックスオブジェクトのアドレス。
戻り値: 成功すると 0 を返します。失敗するとエラーコードを返します（例: デッドロックが検出された場合など）。
pthread_mutex_trylock()
ミューテックスをロックしようと試みます。
もしミューテックスが利用可能（アンロックされている）なら、すぐにロックして 0 を返します。
もし他のスレッドがすでにロックしている場合は、待たずにすぐにエラーコード EBUSY を返します。
使い方:

C

int result = pthread_mutex_trylock(&mutex);
if (result == 0) {
    // ロック成功
    // --- クリティカルセクション ---
    // ...
    // --- クリティカルセクション終了 ---
    pthread_mutex_unlock(&mutex);
} else if (result == EBUSY) {
    // 他のスレッドがロック中だった
    // 必要なら別の処理を行う
} else {
    // その他のエラー
}
引数: ロックしようとするミューテックスオブジェクトのアドレス。
戻り値: 成功すると 0、ロック中だった場合は EBUSY、その他のエラーの場合は対応するエラーコードを返します。
pthread_mutex_timedlock() (オプション)
指定した絶対時間まで、ミューテックスが利用可能になるのを待ちます。
時間内にロックできれば 0 を返します。
指定した時間までにロックできなかった場合は、エラーコード ETIMEDOUT を返します。
pthread_mutex_lock() のように無期限に待つのではなく、タイムアウトを設定したい場合に使います。
使い方:

C

#include <time.h> // timespec のために必要

struct timespec timeout;
// 絶対時間を設定 (例: 現在時刻から1秒後)
clock_gettime(CLOCK_REALTIME, &timeout);
timeout.tv_sec += 1;

int result = pthread_mutex_timedlock(&mutex, &timeout);
if (result == 0) {
    // ロック成功
    // --- クリティカルセクション ---
    // ...
    // --- クリティカルセクション終了 ---
    pthread_mutex_unlock(&mutex);
} else if (result == ETIMEDOUT) {
    // タイムアウトした
} else {
    // その他のエラー
}
引数:
第1引数: ロックするミューテックスオブジェクトのアドレス。
第2引数: タイムアウトする絶対時間 (struct timespec型) のアドレス。
戻り値: 成功すると 0、タイムアウトした場合は ETIMEDOUT、その他のエラーの場合は対応するエラーコードを返します。
4. ミューテックスのアンロック
共有リソースへのアクセスが終わったら、他のスレッドがアクセスできるようにミューテックスをアンロックします。

pthread_mutex_unlock()
ロックされているミューテックスを解放します。
このミューテックスのロックを待っていた他のスレッドがいれば、そのうちの一つがロックを獲得できるようになります。
使い方:

C

// (ロック処理とクリティカルセクションの後で)
int result = pthread_mutex_unlock(&mutex);
if (result != 0) {
    // エラー処理 (自分がロックしていないミューテックスをアンロックしようとした場合など)
}
引数: アンロックするミューテックスオブジェクトのアドレス。
戻り値: 成功すると 0 を返します。失敗するとエラーコードを返します。
注意点:
自分がロックしたミューテックスのみをアンロックしてください。
ロックしていないミューテックスや、他のスレッドがロックしたミューテックスをアンロックしようとすると、未定義の動作を引き起こす可能性があります（ミューテックスの種類によってはエラーが返ることもあります）。
ロックとアンロックは必ず対にしてください。 アンロックを忘れると、他のスレッドが永遠に待機し続けるデッドロック状態になる可能性があります。
これらの関数を適切に使うことで、マルチスレッドプログラムにおけるデータの整合性を保ち、安全に共有リソースへアクセスすることができます。